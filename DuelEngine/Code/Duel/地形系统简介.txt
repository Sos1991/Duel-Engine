嗯, 终于开始写这个了

地形系统嘛, 之前没怎么考虑的, 知道是个大问题, 还有很多书通篇就只讲地形这个问题, 所以之前为了处理其他各种各样的小麻烦, 我一直没有开始真正着手地形系统,
这几天专门看了几个地形系统的技术说明以及实现, 结合我以前了解的姿势, 我决定使用chunklod来实现这边的地形系统.

其实并不是因为chunklod能够实现超大地形啦(误)(其他地形系统也可以, 只要动态加载/卸载就可以的, 只是太麻烦)

言归正传
再废话一次, 这次的地形基于chunklod, 个人认为chunklod对地形的还原度非常好, 无论相机怎么摆放和移动, 地形的起伏都不会有太大变化, 特别是和geomipmap/geoclipping
技术对比起来. 而且使用四叉树裁剪, 方便快捷易懂.

下面再简要介绍一下chunklod的技术, 这里忽略掉的相关细节我都写在另一篇文章里了, 需要更多了解请移步.
首先是四叉树分割, 整个大地形要求必须为2^n+1 x 2^n+1的正方形, 然后就像普通的四叉树一样对该地形块进行切割, 
{题外话, 至于什么时候切到头, 我推荐采用指定分块大小式切割法,而不是指定深度切割法或者是ogre的最大/最小分块切割法,
这样做的理由是:指定深度法会切出很多不必要的分块(最顶层的分块, 大小为2x2, 绝大多数的时候用不到), 指定最大/最小
分块法切分是ogre为了兼容16bit的顶点缓存而使用的, 由此带来的麻烦远远超出我的承受能力(实话, 太麻烦太麻烦, ogre就是擅长弯弯绕, 想知道详情请移步到我另一篇文章)
指定分块大小式可以根据不同的游戏需要, 划分出不同深度的地形块, 指定分块越大, 四叉树深度越小.适用的地形更扁平.}
每个分块存有一个max geometry error的值, 用于记录该分块里的最大的几何误差, 也就是该分块的顶点和实际的全细节的地表的最大差别, 
具体的计算方法是使用该层级顶点的每个拟合三角形来计算每个全细节地表的顶点误差, 取区域内的最大值作为四叉树节点的geometry error, 还是那句话, 详情移步...
然后确保每个深度的节点的几何误差都是相等的, 每个父节点的最大集合误差都大于子节点.
裁剪时, 我们指定一个可容忍的屏幕空间误差tau, 设每个节点的集合误差为E, 如果满足 tau > E / dist_to_camera * K, K为相机缩放系数, 
是一个常量: K = viewport_width / (2*tan(fov/2)), 即渲染该节点, 否则向其子节点递归计算.

(我艹我居然背下了这个公式.. 看来真是写得太多了)

然后说说实现

关于地形的高度图, 我们存储一个float的二位链表, 这个应该是没有什么疑问的了, 当然每个方向大小必然是2^n+1, 然后根据该高度图生成实际的顶点buffer.
顶点buffer的存储方式是, 地形从左下角开始到右上角, 先行后列的顺序, 然后接着是裙边的存储, 先存横向的, 从下到上, 然后是纵向的, 从左到右. 裙边的顶点单独出来, 
不和地形公用, 因此需要从地形中拷贝出来. 记住我们是以地形块中点作为地形的中心的, 顶点的x,z位置可以为负数.

每个四叉树持有的仅仅是顶点序号buffer, 这样我们就可以仅仅通过构造顶点数据来实现区块绘制了.